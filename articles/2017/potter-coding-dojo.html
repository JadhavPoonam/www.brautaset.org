<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>The "Potter" Coding Dojo (in Clojure)</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Stig Brautaset">
<link rel="stylesheet" type="text/css" href="/css/main.css" />
<link rel="icon" type="image/png" href="/images/icon.png" />
<script type="text/javascript">
if(/superloopy.io/.test(window.location.hostname)) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-4113456-6', 'auto');
  ga('send', 'pageview');
}
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>

<div id="org-div-home-and-up">
  <a href="/"><img src="/images/logo.png" alt="Superloopy Logo"/></a>
  <nav>
    <ul>
      <li><a accesskey="H" href="/"> Home </a></li>
      <li><a accesskey="p" href="/publications.html"> Publications </a></li>
      <li><a accesskey="A" href="/about.html"> About </a></li>
      <li><a accesskey="c" href="/contact.html"> Contact </a></li>
      <li>Licence: <a accesskey="l" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></li>
    </ul>
  </nav>
</div>
<div id="content">
<h1 class="title">The "Potter" Coding Dojo (in Clojure)</h1>
<div class="abstract">
<p>
Detailing my trials and tribulations with the "Potter" coding dojo
problem, with code examples in Clojure.
</p>

</div>
<p>
At the end of May our remote-first company met up for one of our
thrice-yearly week-long meetups. One of the objectives is to socialise
and do group activites that build psychological safety so that we feel
safe to take risks and feel vulnerable in front of each other. This
means we can communicate more confidently &amp; efficiently when we are
back in our remote offices.
</p>

<p>
This time we met up in Majorca<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> and sessions included
ice-breakers (people-bingo; building a tower with marshmallow, tape
and spaghetti; etc), building a Technology Radar, Coding Dojo, How To
Master Git, Biomechanics For Desk People, and lightning talks&#x2014;to
mention a few. (We also celebrated a product launch
and&#x2014;yes&#x2014;managed to find time for some bathing, paddling—and even a
couple morning runs.)
</p>

<p>
It is the Coding Dojo I want to talk about in this post. Or; not
actually the session itself, but my efforts to solve one of the
problems featured in it. It was briefly stated but surprisingly
deep and I have found myself thinking about it a lot since.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgea220de">A Warning</a></li>
<li><a href="#orgaa22b8e">The Problem</a></li>
<li><a href="#orgd64a0f0">Towards a (simplistic) solution</a></li>
<li><a href="#orge7fd16b">Finding a solution <i>at all</i> for large purchases</a></li>
<li><a href="#org4400fcf">Actually passing tests for edge cases</a></li>
<li><a href="#orgfabeabd">Towards a moderately fast, correct &amp; <i>robust</i> solution</a>
<ul>
<li><a href="#org143789e">Experimenting in a Clojure REPL</a></li>
<li><a href="#orgf661e75">A tour of my final solution</a></li>
<li><a href="#org53734cf">Potential Improvements</a></li>
</ul>
</li>
<li><a href="#org1c77885">Epilogue</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgea220de" class="outline-2">
<h2 id="orgea220de">A Warning</h2>
<div class="outline-text-2" id="text-orgea220de">
<p>
If you are considering doing this Coding Dojo yourself, you may want
to postpone reading this until you do because it provides not one but
<i>two</i> different solutions that passes all the suggested test cases.
</p>
</div>
</div>

<div id="outline-container-orgaa22b8e" class="outline-2">
<h2 id="orgaa22b8e">The Problem</h2>
<div class="outline-text-2" id="text-orgaa22b8e">
<p>
(Paraphrased by yours truly; the original is over at <a href="http://codingdojo.org/kata/Potter/">codingdojo</a>.)
</p>

<ul class="org-ul">
<li>There is a bookshop that has only five distinct books; Let's call
them 1&#x2013;5</li>
<li>The shop has unlimited quantities of each book</li>
<li>Each book costs £8</li>
<li>You can get a discount for buying several <i>distinct</i> books as a unit</li>
<li>There is <i>no</i> discount for buying two (or more) copies of the same
book as a unit</li>
<li>A purchase can contain multiple units, thus you can get multiple
discounts for a single purchase</li>
</ul>

<p>
These are the discounts:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">distinct books</th>
<th scope="col" class="org-right">discount %</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">2 distinct books</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">3 distinct books</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">4 distinct books</td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-left">5 distinct books</td>
<td class="org-right">25</td>
</tr>
</tbody>
</table>


<p>
Your mission: write a function to calculate the price of a purchase,
such that the customer always pays the minimum available price.
</p>

<p>
Example: Buying the books 1, 2 &amp; 3 can be put through the till in
several different ways:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">#1</td>
<td class="org-left">Individually (no discounts)</td>
<td class="org-left">\(£8 \times 3 = £24\)</td>
</tr>

<tr>
<td class="org-left">#2</td>
<td class="org-left">Discount for two of the books<sup><a id="fnr.1.100" class="footref" href="#fn.1">1</a></sup></td>
<td class="org-left">\(£8 + 2 \times £8 \times (1 - 0.05) = £23.2\)</td>
</tr>

<tr>
<td class="org-left">#3</td>
<td class="org-left">Discount for three books</td>
<td class="org-left">\(3 \times £8 \times (1 - 0.1) = £21.6\)</td>
</tr>
</tbody>
</table>

<p>
In this case, your function should pick option #3 as it is the
cheapest.
</p>
</div>
</div>

<div id="outline-container-orgd64a0f0" class="outline-2">
<h2 id="orgd64a0f0">Towards a (simplistic) solution</h2>
<div class="outline-text-2" id="text-orgd64a0f0">
<p>
I immediately thought that this was a combinatorial problem scoured
Clojure's collections library for suitable combinatorial operators. I
didn't find what I wanted in the standard library, but
<code>clojure.math.combinatorics</code> appeared to have what I needed.
</p>

<p>
<code>clojure.math.combinatorics/partitions</code> returs all the different ways to
partition the input into subsets, which sounds like it might work. I
felt I was ready to start coding.
</p>

<p>
Let's start easy, with an import statement for
<code>clojure.math.combinatorics</code>, a <code>def</code> for our book price, and a map of
available discounts:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">ns</span> <span style="color: #0097A7;">potter.core</span>
  (<span style="color: #B71C1C;">:require</span> [<span style="color: #0097A7;">clojure.math.combinatorics</span> <span style="color: #B71C1C;">:as</span> combo]))

(<span style="color: #00796b;">def</span> <span style="color: #EF6C00;">book-price</span> 8)

(<span style="color: #00796b;">def</span> <span style="color: #EF6C00;">discount</span> {2 0.95
               3 0.9
               4 0.8
               5 0.75})
</pre>
</div>

<p>
Then let's try to price a single partition. Because <code>combo/partitions</code>
returns <i>all</i> possible partitions, some have the same book twice in it.
This makes no sense with our discount structure. However, we can just
price superfluous books as if they were bought on their own, and the
price attempts should be discarded by more optimal sets of partitions.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">price-partition</span>
  [books]
  (<span style="color: #00796b;">let</span> [unique (<span style="color: #B71C1C;">count</span> (<span style="color: #B71C1C;">distinct</span> books))
        mult (<span style="color: #00796b;">or</span> (discount unique) 1)]
    (* book-price
       (+ (* unique mult)
          (* (- (<span style="color: #B71C1C;">count</span> books) unique))))))
</pre>
</div>

<p>
We're ready to price a <i>sequence</i> of partitions, each with their own
discount applied, to make up a whole purchase.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">price-partition-seq</span>
  [partitions]
  (<span style="color: #00796b;">-&gt;&gt;</span> partitions
       (<span style="color: #B71C1C;">map</span> price-partition)
       (<span style="color: #B71C1C;">reduce</span> +)))
</pre>
</div>

<p>
Now, all we need to do is make our top-level price function that takes
our input and returns the best price we can give. It is a brute force
solution that takes the input and first calculates all possible ways
to partition that into subsets, then calculates the <i>price</i> for each of
those subsets, sorts the list of prices and grabs the lowest one.
Simples!
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">price</span>
  [books]
  (<span style="color: #00796b;">-&gt;&gt;</span> books
       <span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions
       (<span style="color: #B71C1C;">map</span> price-partition-seq)
       sort
       first))
</pre>
</div>

<p>
Looks great! Let's try it out against some of the provided test
cases<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #B71C1C;">testing</span> <span style="color: #689f38;">"no discounts"</span>
  (<span style="color: #B71C1C;">are</span> [total books]
      (= total (price books))
    0 []
    8 [1]
    16 [2 2]
    24 [3 3 3]
    32 [4 4 4 4]
    40 [5 5 5 5 5]))
</pre>
</div>

<p>
Alright!
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #B71C1C;">testing</span> <span style="color: #689f38;">"Simple discounts"</span>
  (<span style="color: #B71C1C;">are</span> [total books]
      (= total (price books))
    (* 16 95/100) [1 2]
    (* 16 95/100) [1 3]
    (* 16 95/100) [1 4]
    (* 16 95/100) [1 5]
    (* 8 3 9/10) [1 3 5]
    (* 8 4 8/10) [1 2 3 5]
    (* 8 5 75/100) [1 2 3 4 5]))
</pre>
</div>

<p>
Winning!
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #B71C1C;">testing</span> <span style="color: #689f38;">"Multiple discounts"</span>
  (<span style="color: #B71C1C;">are</span> [total books]
      (= total (price books))
    (+ 8 (* 2 8 95/100)) [1 1 2]
    (* 2 (* 2 8 95/100)) [1 1 2 2]
    (+ (* 8 4 8/10) (* 8 2 95/100)) [1 1 2 3 3 4]
    (+ 8 (* 5 8 75/100)) [1 2 2 3 4 5]))
</pre>
</div>

<p>
Still got it!
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #B71C1C;">testing</span> <span style="color: #689f38;">"Edge cases"</span>
  (<span style="color: #B71C1C;">are</span> [total books]
      (= total (price books))
    (* 2 (* 8 4 8/10)) [1 1 2 2 3 3 4 5]
    (+ (* 3 (* 8 5 75/100)) (* 2 8 4 8/10)) [1 1 1 1 1
                                             2 2 2 2 2
                                             3 3 3 3
                                             4 4 4 4 4
                                             5 5 5 5]))
</pre>
</div>

<p>
<i>BOOOOOO! Failed!</i>
</p>

<p>
That last edge case has 23 books in it, and finding all the possible
partitions is a function whose time consumption grows rapidly with the
number of books. For 13 to 15 books the time taken for this function
roughly triples for each book added, so 23 books will take rather a
long time. Witness:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0097A7;">potter.core</span>&gt; (<span style="color: #B71C1C;">time</span>
              (<span style="color: #B71C1C;">count</span>
               (<span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions
                [1 1 1
                 2 2 2
                 3 3 3
                 4 4
                 5 5])))
<span style="color: #689f38;">"Elapsed time: 1487.052629 msecs"</span>
<span style="color: #607d8b;">;; </span><span style="color: #607d8b;">=&gt; 200549</span>

<span style="color: #0097A7;">potter.core</span>&gt; (<span style="color: #B71C1C;">time</span>
              (<span style="color: #B71C1C;">count</span>
               (<span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions
                [1 1 1
                 2 2 2
                 3 3 3
                 4 4 4
                 5 5])))
<span style="color: #689f38;">"Elapsed time: 4089.57496 msecs"</span>
<span style="color: #607d8b;">;; </span><span style="color: #607d8b;">=&gt; 573003</span>

<span style="color: #0097A7;">potter.core</span>&gt; (<span style="color: #B71C1C;">time</span>
              (<span style="color: #B71C1C;">count</span>
               (<span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions
                [1 1 1
                 2 2 2
                 3 3 3
                 4 4 4
                 5 5 5])))
<span style="color: #689f38;">"Elapsed time: 12744.500346 msecs"</span>
<span style="color: #607d8b;">;; </span><span style="color: #607d8b;">=&gt; 1688360</span>
</pre>
</div>

<p>
It's time to try a different approach.
</p>
</div>
</div>

<div id="outline-container-orge7fd16b" class="outline-2">
<h2 id="orge7fd16b">Finding a solution <i>at all</i> for large purchases</h2>
<div class="outline-text-2" id="text-orge7fd16b">
<p>
Although the simple solution works for small numbers of books, it is
impractical for larger stacks of books. I felt that it might be
possible to break the problem down somewhat, or at least approximate
the solution for larger problems. I renamed my <code>price</code> function to
<code>best-price</code> and added a new <code>fast-price</code> function<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">fast-price</span>
  [books]
  (<span style="color: #00796b;">loop</span> [counts (<span style="color: #00796b;">-&gt;&gt;</span> books frequencies vals sort)
         total 0]
    (<span style="color: #00796b;">if</span> (<span style="color: #B71C1C;">seq</span> counts)
      (<span style="color: #00796b;">let</span> [c (<span style="color: #B71C1C;">first</span> counts)
            n (<span style="color: #B71C1C;">count</span> counts)
            p (* c (price-partition (<span style="color: #B71C1C;">take</span> n (<span style="color: #B71C1C;">iterate</span> inc 1))))]
        (<span style="color: #00796b;">recur</span> (<span style="color: #00796b;">-&gt;&gt;</span> counts
                    (<span style="color: #B71C1C;">map</span> #(- <span style="color: #EF6C00;">%</span> c))
                    (<span style="color: #B71C1C;">remove</span> zero?))
               (+ total p)))
      total)))
</pre>
</div>

<p>
Then it was a case of finding a suitable threshold to switch from one
to the other. I checked the wind direction, phases of the moon, read
my tea leaves and goat entrails and came up with:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">price</span>
  [books]
  (<span style="color: #00796b;">if</span> (&lt; (<span style="color: #B71C1C;">count</span> books) 10)
    (best-price books)
    (fast-price books)))
</pre>
</div>

<p>
Job done! Well, sort-of. This solution is fast and finds <i>a</i> price, but
it does not find <i>the best</i> price for the final edge case.
</p>
</div>
</div>

<div id="outline-container-org4400fcf" class="outline-2">
<h2 id="org4400fcf">Actually passing tests for edge cases</h2>
<div class="outline-text-2" id="text-org4400fcf">
<p>
My fast solution eagerly tries to build as big partitions as possible
from the remaining books. So if you have the following: 1 1 2 2 3 3 4
5 it will price that as:
</p>

<p>
\(£8 \times 5 \times (1 - 0.25) + £8 \times 3 \times (1 - 0.9) = £51.60\)
</p>

<p>
However, it's actually cheaper to price that as two partitions of four
books:
</p>

<p>
\(2 \times £8 \times 4 \times (1 - 0.2) = £51.20\)
</p>

<p>
After a bit of trial-and-error in the Clojure REPL I felt confident
that this was the only such edge case, and decided to just build my
solution around that. I deleted most of the code I had, along the way
micro-optimised<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> fast price lookup for a unit of books. This map
directly gave the price for a stack of 1-5 unique books, having the
discount already added to it.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">def</span> <span style="color: #EF6C00;">fast-price-lookup</span>
  <span style="color: #673ab7;">"Pre-calculated prices (with discount)</span>
<span style="color: #673ab7;">  for a stack of up to 5 distinct books."</span>
  {1 book-price
   2 (* 2 book-price 95/100)
   3 (* 3 book-price 9/10)
   4 (* 4 book-price 8/10)
   5 (* 5 book-price 75/100)})
</pre>
</div>

<p>
I then did a variety of my previous <code>fast-price</code> function. I separated
all the books into piles of distinct books, then built the biggest
sets of unique books I could (by taking one from each pile) and priced
them as a unit <i>unless</i> I reached a state that I recognised I could
more beneficially price as \(4 + 4\) than \(5 + 3\) books. Here's the code
for that:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">price</span>
  [books]

  <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">Separate the books into piles of</span>
  <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">individual books</span>
  (<span style="color: #00796b;">loop</span> [book-piles (<span style="color: #00796b;">-&gt;&gt;</span> books
                         frequencies
                         vals
                         sort)
         total 0]

    <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">Any more piles of books left?</span>
    (<span style="color: #00796b;">if</span> (<span style="color: #B71C1C;">seq</span> book-piles)

      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">Do we hit the special case</span>
      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">where two four-book stacks are</span>
      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">cheaper than two stacks of</span>
      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">three and five unique books</span>
      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">each?</span>
      (<span style="color: #00796b;">if</span> (= '(1 1 2 2 2) book-piles)

        <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">Return current total plus the</span>
        <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">cost of two stacks of four</span>
        <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">unique books.</span>
        (+ total (* 2 (fast-price-lookup 4)))

        <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">Take one book from each</span>
        <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">remaining pile &amp; add the cost</span>
        <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">of this stack of books to the</span>
        <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">running total.</span>
        (<span style="color: #00796b;">recur</span> (<span style="color: #00796b;">-&gt;&gt;</span> book-piles
                    (<span style="color: #B71C1C;">map</span> dec)
                    (<span style="color: #B71C1C;">remove</span> zero?))
               (+ total
                  (fast-price-lookup
                   (<span style="color: #B71C1C;">count</span> book-piles)))))

      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">No more piles of books left;</span>
      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">return total.</span>
      total)))
</pre>
</div>

<p>
There's a lot to like about this. It's dirt simple, and <i>fast</i>. I can
price millions of books with this, no problems.
</p>

<p>
I was very, very pleased with myself until <a href="https://michtran.ca">Michelle</a>, a colleague,
pointed out that it is highly sensitive to changes in the discount
amounts. She even went as far as calling it <i>cheating</i> which made me
feel like taking a few deep breaths into a paper bag. But she is
right! Change the discount amount given for four books and the pricing
function may start to exhibit weird behaviour.
</p>
</div>
</div>

<div id="outline-container-orgfabeabd" class="outline-2">
<h2 id="orgfabeabd">Towards a moderately fast, correct &amp; <i>robust</i> solution</h2>
<div class="outline-text-2" id="text-orgfabeabd">
<p>
Michelle tried to show me how to solve the problem using <i>Maths</i> but
kept on being distracted from reaching a solution by my questions
about her notation<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>. We did manage to satisfy ourselves that
given a huge amount of books we can break the problem into smaller
chunks, of size at most \(N \times N\) where \(N\) is the biggest number
of books we offer a lump discount for. The problem is that in our case
\(N = 5\) and \(5 \times 5 = 25\) is more books than we have in the edge
case that we <i>already</i> failed to handle.
</p>

<p>
This was as far as I got at this work trip, but I've been thinking
about the problem (too much) since. Is it possible to make a solution
that is correct, fast enough to handle all the provided edge cases,
and <i>robust</i> against changes in the discounts? It feels like it should
be.
</p>

<p>
I think there will still be a combinatorical element to the solution.
My hope is to add some domain-informed restrictions such that we can
pass all the suggested test cases in a reasonable time span. I believe
it should be possible. I can think of some restrictions:
</p>

<ul class="org-ul">
<li>Don't generate partitions with more than N items, where N is max
number of books we offer a discount for (i.e. 5)</li>
<li>Don't generate partitions with duplicates</li>
</ul>

<p>
One approach I thought of was to generate a set of different <i>shapes</i> of
sets that fit those constraints, and try to fit the books we have into
these sets.
</p>
</div>

<div id="outline-container-org143789e" class="outline-3">
<h3 id="org143789e">Experimenting in a Clojure REPL</h3>
<div class="outline-text-3" id="text-org143789e">
<p>
I still think that <code>combo/partitions</code> can help me find all the different
<i>shapes</i> or partitions, with a bit of creative management of its input,
so let's swap to a REPL and try just that.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0097A7;">potter.core</span>&gt; (<span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions [1 1 1])
<span style="color: #607d8b;">;; </span><span style="color: #607d8b;">=&gt; (([1 1 1]) ([1 1] [1]) ([1] [1] [1]))</span>
</pre>
</div>

<p>
Great! That looks like just the ticket. Let's print each set of
partitions on a separate line, and count all the different solutions
for, say, 6 books.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0097A7;">potter.core</span>&gt; (<span style="color: #B71C1C;">count</span>
              (<span style="color: #B71C1C;">map</span> prn
                   (<span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions
                    (<span style="color: #B71C1C;">repeat</span> 6 1))))
([1 1 1 1 1 1])
([1 1 1 1 1] [1])
([1 1 1 1] [1 1])
([1 1 1 1] [1] [1])
([1 1 1] [1 1 1])
([1 1 1] [1 1] [1])
([1 1 1] [1] [1] [1])
([1 1] [1 1] [1 1])
([1 1] [1 1] [1] [1])
([1 1] [1] [1] [1] [1])
([1] [1] [1] [1] [1] [1])
<span style="color: #607d8b;">;; </span><span style="color: #607d8b;">=&gt; 11</span>
</pre>
</div>

<p>
Ah, looking good, except we have to get rid of any solutions with
subsets of more than N elements. Remove takes care of that:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0097A7;">potter.core</span>&gt; (<span style="color: #B71C1C;">count</span>
              (<span style="color: #B71C1C;">map</span> prn
                   (<span style="color: #B71C1C;">remove</span> #(&gt; (<span style="color: #B71C1C;">count</span> (<span style="color: #B71C1C;">first</span> <span style="color: #EF6C00;">%</span>)) 5)
                           (<span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions
                            (<span style="color: #B71C1C;">repeat</span> 6 1)))))
([1 1 1 1 1] [1])
([1 1 1 1] [1 1])
([1 1 1 1] [1] [1])
([1 1 1] [1 1 1])
([1 1 1] [1 1] [1])
([1 1 1] [1] [1] [1])
([1 1] [1 1] [1 1])
([1 1] [1 1] [1] [1])
([1 1] [1] [1] [1] [1])
([1] [1] [1] [1] [1] [1])
<span style="color: #607d8b;">;; </span><span style="color: #607d8b;">=&gt; 10</span>
</pre>
</div>

<p>
Success! And now I realised that we can rank those patterns by their
price, so that when we try to fit our actual set of books we can stop
as soon as we find our first match&#x2014;because any later matches we find
<i>must</i> be more expensive. Let's just check that we can call this with a
value bigger than 23:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #0097A7;">potter.core</span>&gt; (<span style="color: #B71C1C;">time</span>
              (<span style="color: #B71C1C;">count</span>
               (<span style="color: #B71C1C;">remove</span> #(&gt; (<span style="color: #B71C1C;">count</span> (<span style="color: #B71C1C;">first</span> <span style="color: #EF6C00;">%</span>)) 5)
                       (<span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions
                        (<span style="color: #B71C1C;">repeat</span> 25 1)))))
<span style="color: #689f38;">"Elapsed time: 54.559845 msecs"</span>
<span style="color: #607d8b;">;; </span><span style="color: #607d8b;">=&gt; 377</span>
</pre>
</div>

<p>
Alright! I think that will suffice. Now let's get to work on this
solution.
</p>

<p>
<i>Days later</i>
</p>

<p>
Oh boy. I just came back from a very, very deep rabbit-hole. Rather
than trying to detail the process, let's just skip straight to a tour
of the result&#x2026;
</p>
</div>
</div>

<div id="outline-container-orgf661e75" class="outline-3">
<h3 id="orgf661e75">A tour of my final solution</h3>
<div class="outline-text-3" id="text-orgf661e75">
<p>
Let's start with the basics. We need the <code>clojure.math.combinatorics</code>
package, so let's import that. And let's define our book price too.
You'll notice that this time I'm back to defining the discounts more
simply, because I imagine that's the most frequent changes one would
make.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">ns</span> <span style="color: #0097A7;">potter.core</span>
  (<span style="color: #B71C1C;">:require</span>
   [<span style="color: #0097A7;">clojure.math.combinatorics</span> <span style="color: #B71C1C;">:as</span> combo]))

(<span style="color: #00796b;">def</span> <span style="color: #EF6C00;">book-price</span> 8)

(<span style="color: #00796b;">def</span> <span style="color: #EF6C00;">discounts</span>
  {2 5/100
   3 10/100
   4 20/100
   5 25/100})
</pre>
</div>

<p>
We know we'll price <i>partitions</i> of books, so let's make a function to
price each partition, and one to price a <i>collection</i> of partitions.
These doesn't need to be terribly efficient, because we won't be
calling them very often.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn-</span> <span style="color: #0097A7;">price-partition</span>
  <span style="color: #673ab7;">"Price a partition of N distinct books."</span>
  [n]
  (<span style="color: #00796b;">let</span> [discount (<span style="color: #00796b;">or</span> (discounts n) 0)
        multiplier (- 1 discount)]
    (* book-price n multiplier)))

(<span style="color: #00796b;">defn-</span> <span style="color: #0097A7;">sum-price-partitions</span>
  <span style="color: #673ab7;">"Calculate the sum of a sequence of</span>
<span style="color: #673ab7;">  book partitions."</span>
  [parts]
  (<span style="color: #00796b;">-&gt;&gt;</span> parts
       (<span style="color: #B71C1C;">map</span> price-partition)
       (<span style="color: #B71C1C;">reduce</span> +)))
</pre>
</div>

<p>
Now we need a way to create all the possible ways to partition our
number of books into parts. There is never a point in considering any
parts larger than the max number of books we offer a discount for, so
let's find that first. <code>partitions</code> returns a nested sequence of
integers, where each integer is a count of books.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn-</span> <span style="color: #0097A7;">max-partition-size</span>
  <span style="color: #673ab7;">"Given a map of discounts picks</span>
<span style="color: #673ab7;">  the max partition size to consider."</span>
  [discounts]
  (<span style="color: #00796b;">-&gt;&gt;</span> discounts keys sort last))

(<span style="color: #00796b;">defn-</span> <span style="color: #0097A7;">partitions</span>
  <span style="color: #673ab7;">"Produce all sequence of possible</span>
<span style="color: #673ab7;">  partitions representing N number of</span>
<span style="color: #673ab7;">  books, constrained by a max size for</span>
<span style="color: #673ab7;">  each partition."</span>
  [n max-part-size]
  (<span style="color: #00796b;">-&gt;&gt;</span> (<span style="color: #B71C1C;">repeat</span> n 1)
       <span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>partitions
       (<span style="color: #B71C1C;">map</span> #(<span style="color: #B71C1C;">map</span> count <span style="color: #EF6C00;">%</span>))
       (<span style="color: #B71C1C;">remove</span> #(&gt; (<span style="color: #B71C1C;">first</span> <span style="color: #EF6C00;">%</span>) max-part-size))))
</pre>
</div>

<p>
We don't need to know the actual books to price them (because all
books cost the same). Since we now have all the possible partitions of
books we can calculate the price of all those partitions, and rank
them so that the "best" partitions go first. We now have a sorted list
of prices that we will pay, mapped to a set of partitions we have to
separate the books in to pay that price. Though, we don't know <i>which</i>
of those prices we'll end up paying yet.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn-</span> <span style="color: #0097A7;">sort-partitions-by-price</span>
  <span style="color: #673ab7;">"Zip sequences of prices &amp; partitions</span>
<span style="color: #673ab7;">  together,and sort by price so the</span>
<span style="color: #673ab7;">  cheapest sequence of partitions comes</span>
<span style="color: #673ab7;">  first."</span>
  [prices parts]
  (<span style="color: #00796b;">-&gt;&gt;</span> (<span style="color: #B71C1C;">map</span> vector prices parts)
       (<span style="color: #B71C1C;">sort-by</span> first)))
</pre>
</div>

<p>
I'm going to borrow an element from my previous solution and separate
the entire purchase into stacks of distinct books. This is represented
as a vector of integers, where each integer is the count of books in
that stack. We then need a function to pick a selection (partition) of
books from these stacks and return the new stack. We also need a
function to find all the different ways to pick <i>N</i> books from <i>M</i> stacks
of books. Here are both of those.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn-</span> <span style="color: #0097A7;">pick-books</span>
  <span style="color: #673ab7;">"Pick books from the given stacks</span>
<span style="color: #673ab7;">  according to indices given; return</span>
<span style="color: #673ab7;">  remaining stacks of books."</span>
  [stacks indices]
  <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">update-in *really* doesn't like seqs,</span>
  <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">hence we ensure stacks is a vector here</span>
  (<span style="color: #00796b;">loop</span> [stacks (<span style="color: #B71C1C;">vec</span> stacks)
         [x &amp; xs] indices]
    (<span style="color: #00796b;">if-not</span> x
      (<span style="color: #B71C1C;">remove</span> zero? stacks)
      (<span style="color: #00796b;">recur</span>
       (<span style="color: #B71C1C;">update-in</span> stacks [x] dec) xs))))


(<span style="color: #00796b;">defn-</span> <span style="color: #0097A7;">pick-combinations</span>
  <span style="color: #673ab7;">"All the unique ways to pick N</span>
<span style="color: #673ab7;">  books from a set of stacks."</span>
  [stacks n]
  (<span style="color: #0097A7;">combo</span><span style="color: #212121; background-color: #FAFAFA;">/</span>combinations
   (<span style="color: #B71C1C;">range</span> (<span style="color: #B71C1C;">count</span> stacks)) n))
</pre>
</div>

<p>
We are now arriving at the difficult bit&#x2026; We need a function to
check if it's possible to map our desired purchase of books to a
particular set of partitions of books. Or put another way, given a seq
of partition sizes can we pick all of them (depleeting the set of
books) such that each partition contains distinct books? This is
essenitally a depth-first search.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn-</span> <span style="color: #0097A7;">picks-completely?</span>
  <span style="color: #673ab7;">"Is it possible to pick the given </span>
<span style="color: #673ab7;">  partitions from the stacks of books,</span>
<span style="color: #673ab7;">  such that all the stacks are used up?"</span>
  [parts stacks]
  (<span style="color: #00796b;">loop</span> [stacks stacks
         potential-picks (pick-combinations
                          stacks (<span style="color: #B71C1C;">first</span> parts))
         remaining-parts (<span style="color: #B71C1C;">rest</span> parts)
         backtrack-stack []]

    <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">Have we reached a dead end?</span>
    (<span style="color: #00796b;">if</span> (<span style="color: #B71C1C;">empty?</span> potential-picks)

      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">Can we backtrack to try</span>
      <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">a different path?</span>
      (<span style="color: #00796b;">if</span> (<span style="color: #B71C1C;">empty?</span> backtrack-stack)
        <span style="color: #558b2f;">false</span>
        (<span style="color: #00796b;">let</span> [prev (<span style="color: #B71C1C;">peek</span> backtrack-stack)
              stacks (<span style="color: #B71C1C;">nth</span> prev 0)
              potential-picks (<span style="color: #B71C1C;">nth</span> prev 1)
              parts (<span style="color: #B71C1C;">nth</span> prev 2)]
          (<span style="color: #00796b;">recur</span> stacks
                 (<span style="color: #B71C1C;">rest</span> potential-picks)
                 parts
                 (<span style="color: #B71C1C;">pop</span> backtrack-stack))))

      (<span style="color: #00796b;">let</span> [remaining-stacks
            (pick-books stacks (<span style="color: #B71C1C;">first</span> potential-picks))]
        <span style="color: #607d8b;">;; </span><span style="color: #607d8b;">Have we depleted our stacks of books?</span>
        (<span style="color: #00796b;">if</span> (<span style="color: #B71C1C;">empty?</span> remaining-stacks)
          <span style="color: #558b2f;">true</span>
          (<span style="color: #00796b;">recur</span> remaining-stacks
                 (pick-combinations
                  remaining-stacks
                  (<span style="color: #B71C1C;">first</span> remaining-parts))
                 (<span style="color: #B71C1C;">rest</span> remaining-parts)
                 (<span style="color: #B71C1C;">conj</span> backtrack-stack
                       [stacks
                        potential-picks
                        remaining-parts])))))))
</pre>
</div>

<p>
OK, that was <i>hard</i> &amp; took me many hours to get right. (Plus at least
one to clean up to a point where I would consider showing it to anyone
else.) However, now we have all the pieces and it's relatively easy to
put it all together in our public <code>price</code> function:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">price</span>
  <span style="color: #673ab7;">"Calculates the best price you can get</span>
<span style="color: #673ab7;">  for a collection of books, by splitting</span>
<span style="color: #673ab7;">  it into different partitions and getting</span>
<span style="color: #673ab7;">  the optimal discount achievable."</span>
  [books]
  (<span style="color: #00796b;">if</span> (<span style="color: #B71C1C;">empty?</span> books)
    0
    (<span style="color: #00796b;">let</span> [n (<span style="color: #B71C1C;">count</span> books)
          max-part-size (max-partition-size
                         discounts)
          parts (partitions n max-part-size)
          prices (<span style="color: #B71C1C;">map</span> sum-price-partitions parts)
          price-parts (sort-partitions-by-price
                       prices parts)
          stacks (<span style="color: #00796b;">-&gt;</span> books frequencies vals)]
      (<span style="color: #00796b;">loop</span> [[[price parts] &amp; rest] price-parts]
        (<span style="color: #00796b;">if</span> (picks-completely? parts stacks)
          price
          (<span style="color: #00796b;">recur</span> rest))))))
</pre>
</div>

<p>
Basically we're just looping over all our candidate set of partitions,
cheapest first, and stopping as soon as we find a partition we can
use. The last candiate partition is has every book in a partition of
its own, which <i>must</i> match, so there's no special cases to handle
there.
</p>
</div>
</div>

<div id="outline-container-org53734cf" class="outline-3">
<h3 id="org53734cf">Potential Improvements</h3>
<div class="outline-text-3" id="text-org53734cf">
<p>
This is fast enough, correct enough, and robust enough that I don't
feel like spending any more time on it. However, if I <i>were</i> to make it
work for even bigger inputs (it currently takes 16 seconds to price 53
books on my machine, which is rather longer than I'd like) I think the
two areas of improvement I would consider are:
</p>

<ol class="org-ol">
<li>Finding a better way to calculate suitable partitions than
calculating all partitions and throwing away the unsuitable ones,
and without having to create all those intermediate vectors that we
end up throwing away.</li>
<li>The <code>pick-combinations</code> function is called over and over again with
the same arguments, so it might benefit from memoization.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org1c77885" class="outline-2">
<h2 id="org1c77885">Epilogue</h2>
<div class="outline-text-2" id="text-org1c77885">
<p>
If you want to get into more details and play with this code yourself
you might find it easier to check out my <a href="https://github.com/stig/coding-dojo">coding-dojo repo</a> rather than
piece it together from this blog post.
</p>

<p>
I hope I'm <i>done</i> with this problem now. It's been praying on my mind
for a month, hence I decided to try "writing it out of my
system"&#x2014;and the result is this article. I hope you're happy, whoever
you are who came up with this exercise :-)
</p>
</div>
</div>
<div id="footnotes"><!--Footnotes-->
<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
There are several configurations this discount could apply,
e.g. ((1 + 2) (3)), ((1) (2 + 3)), ((1 + 3) (2)).
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Transcribed into Clojure from <a href="http://codingdojo.org/kata/Potter/">http://codingdojo.org/kata/Potter/</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
I make this sound easy, but it took me <i>hours</i> which probably
would have been better of spent sleeping. (It was the middle of the
night, after all.)
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
Unnecessarily, no doubt.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
I am for some reason unable to remember how to read
mathematical notation so have to re-learn it every time I encounter
it.
</p></div></div>

</div></div>
<div id="postamble" class="status">
<p class="date">Date: 22 June 2017</p>
<p class="author">Author: Stig Brautaset</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
