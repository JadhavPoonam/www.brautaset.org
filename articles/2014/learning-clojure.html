<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Learning Clojure by Solving Euler Problems</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Stig Brautaset">
<link rel="stylesheet" type="text/css" href="/css/main.css" />
<link rel="icon" type="image/png" href="/images/icon.png" />
<script type="text/javascript">
if(/superloopy.io/.test(window.location.hostname)) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-4113456-6', 'auto');
  ga('send', 'pageview');
}
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>

<div id="org-div-home-and-up">
  <a href="/"><img src="/images/logo.png" alt="Superloopy Logo"/></a>
  <nav>
    <ul>
      <li><a accesskey="H" href="/"> Home </a></li>
      <li><a accesskey="p" href="/publications.html"> Publications </a></li>
      <li><a accesskey="A" href="/about.html"> About </a></li>
      <li><a accesskey="c" href="/contact.html"> Contact </a></li>
    </ul>
  </nav>
</div>
<div id="content">
<h1 class="title">Learning Clojure by Solving Euler Problems</h1>
<p>
I'm always interested in new technologies and languages. We're using
Scala at work, and I really quite like the language. I really do like
static (inferred) types. But on the other hand, as an AI graduate Lisp
holds a certain allure and is a language I've wanted to learn for a
long time but somehow never really gotten around to. One (for me)
silly roadblock has been the stupid names of functions like <code>cdr</code> and
<code>car</code> rather than <code>first</code> and <code>rest</code>. Clojure actually fixes this deficiency
in Lisp, so I decided to give it a go.
</p>

<p>
Since I didn't have a particular project in mind I started out by
trying to solve problems from <a href="https://projecteuler.net">Project Euler</a>. The first 2 were simple,
but for the third I needed a pretty fast prime generator. My first
attempt was very simple and produced a correct sequence, but it is
incredibly slow. Here it is:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">naive-primes-seq</span>
  <span style="color: #673ab7;">"Stig's first naive prime number sequence generator."</span>
  []
  (<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">odd-seq</span> []
    (<span style="color: #B71C1C;">filter</span> odd? (<span style="color: #B71C1C;">iterate</span> inc 3)))
  (<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">naive-prime?</span> [n]
    (<span style="color: #B71C1C;">every?</span>
     (<span style="color: #00796b;">fn</span> [x] (<span style="color: #B71C1C;">not=</span> (<span style="color: #B71C1C;">mod</span> n x) 0))
     (<span style="color: #B71C1C;">cons</span> 2 (<span style="color: #B71C1C;">take-while</span>
              (<span style="color: #00796b;">fn</span> [x] (&lt; (* x x) (<span style="color: #B71C1C;">inc</span> n)))
              (odd-seq)))))
  (<span style="color: #B71C1C;">cons</span> 2
        (<span style="color: #B71C1C;">filter</span> naive-prime?
                (odd-seq))))
</pre>
</div>

<p>
The silliest thing about it is that it's generating a list of all
numbers, then filtering out the even ones, and testing all of those.
That was easy to fix, and as you can see I learnt about the <code>#</code> macro as
well in the process. This version is about twice as fast as the above:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">naive-primes-seq4</span>
  <span style="color: #673ab7;">"Stig's 4th naive prime number sequence generator."</span>
  []
  (<span style="color: #00796b;">let</span> [odd-seq (<span style="color: #B71C1C;">iterate</span> #(+ <span style="color: #EF6C00;">%1</span> 2) 3)]
    (<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">prime?</span> [n]
      (<span style="color: #B71C1C;">every?</span>
       #(<span style="color: #B71C1C;">not=</span> (<span style="color: #B71C1C;">mod</span> n <span style="color: #EF6C00;">%1</span>) 0)
       (<span style="color: #B71C1C;">take-while</span>
        #(&lt; (* <span style="color: #EF6C00;">%1</span> <span style="color: #EF6C00;">%1</span>) (<span style="color: #B71C1C;">inc</span> n))
        odd-seq)))
    (<span style="color: #B71C1C;">cons</span> 2
          (<span style="color: #B71C1C;">filter</span> prime?
                  odd-seq))))
</pre>
</div>

<p>
It still an incredibly naive implementation though, and about a
gazillion times slower than the version by <a href="http://clj-me.cgrand.net/2009/07/30/everybody-loves-the-sieve-of-eratosthenes/">Christophe Grand</a>. My
understanding of Clojure was not deep enough to completely understand
how that implementation works. But, I was able to learn some things
(for example the <code>letfn</code> construct) from it and I set out to explore an
idea I had for a fast, lazy Sieve of Eratosthenes.
</p>

<p>
My idea was to keep a set containing prime multiples for fast checking,
and a map where the keys are the primes found so far, and the values
were the highest multiple of it in the set. The set would continually be
pruned for values lower than the current candidate, and the set would be
updated from the keys and values in the map. I even did
micro-optimisations like tripling each prime's value as the initial
value in the set (because even values would never be candidates) and
adding "its" prime to this value twice each time we subsequently updated
the set. My last attempt is shown below.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00796b;">defn</span> <span style="color: #0097A7;">sprimes</span>
  <span style="color: #673ab7;">"Stream of prime numbers using a streaming</span>
<span style="color: #673ab7;">  version of the Sieve of Eratosthenes. Take 2!"</span>
  []
  (<span style="color: #00796b;">letfn</span> [(thrice [x] (* x 3))
          (bump-vals [kv]
            (<span style="color: #00796b;">let</span> [key (<span style="color: #B71C1C;">key</span> kv)]
              [key (+ (<span style="color: #B71C1C;">val</span> kv) (* 2 key))]))
          (map-updates [m c]
            (<span style="color: #00796b;">-&gt;&gt;</span> m
                 (<span style="color: #B71C1C;">filter</span>
                  (<span style="color: #00796b;">fn</span> [entry] (&gt; c (<span style="color: #B71C1C;">val</span> entry))))
                 (<span style="color: #B71C1C;">map</span> bump-vals)
                 (<span style="color: #B71C1C;">into</span> {})))
          (next-prime [m s c]
            (<span style="color: #00796b;">if</span> (s c)
              (<span style="color: #00796b;">recur</span> m s (+ 2 c))
              (<span style="color: #00796b;">let</span> [updates (map-updates m c)]
                (<span style="color: #00796b;">if-not</span> (<span style="color: #B71C1C;">empty?</span> updates)
                  (<span style="color: #00796b;">recur</span> (<span style="color: #B71C1C;">into</span> m updates)
                         (<span style="color: #B71C1C;">into</span> s (<span style="color: #B71C1C;">vals</span> updates))
                         c)
                  (<span style="color: #00796b;">let</span> [tc (thrice c)]
                    (<span style="color: #B71C1C;">cons</span> c
                          (<span style="color: #B71C1C;">lazy-seq</span>
                           (next-prime
                            (<span style="color: #B71C1C;">assoc</span> m c tc)
                            (<span style="color: #B71C1C;">conj</span> s tc)
                            (+ 2 c)))))))))]
    (<span style="color: #B71C1C;">cons</span> 2 (next-prime {} #{} 3))))
</pre>
</div>

<p>
It is a moderate improvement on my naive solutions, but it's still
damn slow! However, at this point I have learnt enough Clojure to
actually understand Christophe's version. And it is sublime! It
accomplishes exactly my goals, but so much more elegantly and
efficiently I hardly know where to start. So I won't! Now, there's not
much I can do to improve the efficiency or elegance of his algorithm,
but I <i>can</i> improve the run speed by making the map <a href="http://clojure.org/transients">transient</a>. By that
minimal change Christophe's algorithm was speeded up by a hefty
factor: from 18 to 13 seconds to retrieve the 1M + 1 prime:
</p>

<div class="org-src-container">
<pre class="src src-clojure">user=&gt; (<span style="color: #B71C1C;">time</span>
        (<span style="color: #00796b;">doall</span>
         (<span style="color: #B71C1C;">take</span> 1
               (<span style="color: #B71C1C;">drop</span> 1000000
                     (grand-lazy-primes)))))
<span style="color: #689f38;">"Elapsed time: 18665.168 msecs"</span>
(15485867)

user=&gt; (<span style="color: #B71C1C;">time</span>
        (<span style="color: #00796b;">doall</span>
         (<span style="color: #B71C1C;">take</span> 1
               (<span style="color: #B71C1C;">drop</span> 1000000
                     (grand-lazy-primes2)))))
<span style="color: #689f38;">"Elapsed time: 13422.726 msecs"</span>
(15485867)
</pre>
</div>

<p>
I think it's fast enough for now, so now I'll continue onto Euler
Problem 4&#x2026;
</p>
</div>
<div id="postamble" class="status">
<p class="author">Author: <a href="/contact.html">Stig Brautaset</a></p>
<p class="licence">Licence: <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
