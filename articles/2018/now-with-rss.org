#+title: Now With RSS!
#+begin_abstract
A post to announce that this site now has an RSS feed, and how I create it.
#+end_abstract
#+category: Org
#+category: Emacs

For a while I've been wanting to add RSS to this site. Not so much
because I think the site really needs it, but because it intrigued me
to figure out to do it using my existing [[../2017/blogging-with-org-mode.org][Emacs Org blogging solution]].

In short, I use [[https://code.orgmode.org/bzg/org-mode/src/master/contrib/lisp/ox-rss.el][ox-rss.el]] (from Org mode's contrib) to produce an RSS
feed from the [[../../index.org][home]] page. I was delighted that tags on headlines were
automatically translated into RSS Categories, with no extra work from
me. However, I had to get over some hurdles before I was able to make
it generate a valid and useful feed:

1. Only /top-level/ headings make it into nodes in the RSS
2. My index page is just that, but I wanted to link to the full article page from the feed
3. No paragraph content is allowed before the entries
4. I wanted my RSS feed to reflect original publication dates of my articles
5. I want it to be easy to create a new entry on the index page

I had to change the headings I used in my index page to get rid of my
old top-level headings containing dividing my full list of post into
their publication year. Not a big loss, I think, as the URL of each
post contains the year, and each post contains its publication date at
the bottom.

To link to the actual post from the RSS feed (rather than to the copy
of the abstract on the index page) I had to add =RSS_PERMALINK= entries
to each of the headings in the index page. One slightly annoying bit
about this is that I can't use the =.org= extension like everywhere
else, I have to change it to the =.html= extension it will be when
published.

Thirdly, the issue of my index page's introductory text not being
allowed in RSS. Solving this was a bit tricky, but I know that Org has
a way to tag sections with =:noexport:= to omit it from being included,
and with a bit of searching I found a promising [[https://emacs.stackexchange.com/a/7578][Emacs StackExchange
Answer]] with a macro I was able to adapt to my use. (The macro should
be all on one line, but I added linebreaks for readability.)

#+BEGIN_SRC org
  ,#+MACRO: no-rss (eval
   (if
    (org-export-derived-backend-p
     org-export-current-backend 'rss)
     "* COMMENT :noexport:"
     ""))

  {{{no-rss}}}
  I'm Stig Brautaset.  [...]
#+END_SRC

What's happening here is that the macro ={{{no-rss}}}=, when the =rss=
export backend is working on this file, will expand to the headline =*
COMMENT :noexport:= thus making sure that paragraph does not end up in
the RSS feed. I have a separate keyword in the file to provide the
alternative description (and RSS Image URL) for the feed. That looks
like this:

#+BEGIN_SRC org
  ,#+RSS_IMAGE_URL: https://www.brautaset.org/etc/icon.png
  ,#+DESCRIPTION: I'm Stig Brautaset, and this is my site's RSS feed.
#+END_SRC

Getting the publication dates right was just a case of applying elbow
grease. To do so all I had to do was to update the =PUBDATE= property
for each entry in the index page to that of the blog post in question.
Since I don't have all that many articles this wasn't too difficult.

Creating a section with a header containing a link to the post page,
adding tags from the post's categories, setting =PUBDATE= and
=RSS_PERMALINK= options, as well as copying the abstract of each post
was not something I wanted to do manually. I had an opportunity to
learn a little more Emacs lisp, and experiment with the Org APIs. This
is what I came up with.

#+BEGIN_SRC emacs-lisp -n -r
  (defun sb/org-kw-get (key)   (ref:macro)
    "Return a lambda that takes an Org keyword
  element and returns its :value property if its :key
  property matches `key'."
    `(lambda (kw)
       (if (equal ,key (org-element-property :key kw))
	   (org-element-property :value kw))))

  (defun sb/parse-metadata ()
    "Call in a blog post to get an entry suitable for
  linking to this post from the index page."
    (interactive)
    (let* ((path (s-chop-prefix
		  (expand-file-name "~/blog/")
		  (buffer-file-name)))
	   (tree (org-element-parse-buffer))

	   (title (org-element-map tree 'keyword
		    (sb/org-kw-get "TITLE") nil t))
	   (date (org-element-map tree 'keyword
		   (sb/org-kw-get "DATE") nil t))
	   (categories (org-element-map tree 'keyword
			 (sb/org-kw-get "CATEGORY")))
	   (abstract (s-join (ref:s-join)
		      ""
		      (org-element-map tree 'special-block
			(lambda (sb)
			  (if (equal "abstract"
				     (org-element-property :type sb))
			      (org-element-interpret-data
			       (org-element-contents sb))))))))

      (with-temp-buffer
	(org-mode)   (ref:org-mode)
	(org-insert-heading)

	;; Would have loved to use `org-insert-link' here but
	;; I can't stop it from presenting a prompt :-(
	(insert "[[file:" path "][" title "]]")

	(insert "\n\n")
	(insert abstract)

	(org-set-property "PUBDATE" date)
	(org-set-property "RSS_PERMALINK"
			  (format "%s.html"
				  (s-chop-suffix ".org" path)))

	;; Need to go back to the first line to set tags
	(goto-char (point-min))
	(org-set-tags-to categories) (ref:set-tags)
	(org-set-tags nil t) ;; adjust tags in the source

	;; Copy the contents of the temporary buffer as a string
	;; *without properties* to my kill ring for pasting into
	;; my index.org file
	(copy-region-as-kill
	 (point-min) (point-max)))))
#+END_SRC

I query the Org parsetree for the title, date and category keywords,
and the =abstract= special block. (I created a little helper [[(macro)][macro]] to
avoid repetition, since I extract three different keywords in the same
way.) Figuring out how to parse out the abstract was much harder, but
I managed something. I'm not so happy about the [[(s-join)][use of s-join]] in this
part, but it does the job.

For generating the text entry I use Org mode programmatically. One
caveat was that some of the APIs (I think most notably the
[[(set-tags)][org-set-tags-to]] call) would not work until I [[(org-mode)][turned on Org mode]] in my
temporary buffer.

So there you go! I think this was all I had to contend with to produce
an RSS feed from this blog. I hope you enjoyed this post!  It ended up
a bit longer than I expected, but there you go.
