<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Rise of the Machine</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Stig Brautaset">
<link rel="stylesheet" type="text/css" href="/css/main.css" />
<link rel="icon" type="image/png" href="/images/icon.png" />
<script type="text/javascript">
if(/superloopy.io/.test(window.location.hostname)) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-4113456-6', 'auto');
  ga('send', 'pageview');
}
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>

<div id="org-div-home-and-up">
  <a href="/"><img src="/images/logo.png" alt="Superloopy Logo"/></a>
  <nav>
    <ul>
      <li><a accesskey="H" href="/"> Home </a></li>
      <li><a accesskey="p" href="/publications.html"> Publications </a></li>
      <li><a accesskey="A" href="/about.html"> About </a></li>
      <li><a accesskey="c" href="/contact.html"> Contact </a></li>
    </ul>
  </nav>
</div>
<div id="content">
<h1 class="title">Rise of the Machine</h1>
<div class="abstract">
<p>
I ruminate on implementing a simple virtual machine&#x2014;for a simple
language&#x2014;in C.
</p>

</div>
<p>
Last week <a href="http://www.google.com/search?q=Norman+Nunley">Norman Nunley</a> got me interested in the <a href="http://icfpcontest.org/">ICFP challenge 2006</a>,
despite it being over. It involved implementing a Universal Machine
following a (hilarious) spec. This was needed to run a program that
you were given; this program would then give you instructions on what
to do from there.
</p>

<p>
I had never written a virtual machine before: I always imagined it too
hard to even try. I was wrong. It took me around 7-8 hours; spread over
an evening, the following morning and a couple of hours at work (sorry
boss, it was too addictive&#x2014;I blame Norman); to get a working machine.
I did most of the work alone, but I needed Norman's help to clarify
parts of the spec and in some debugging.
</p>

<p>
I was amazed when it turned out this "huge scary thing", which I'd
imagined a VM to be, clocked in at less than 300 lines of C. It wasn't
fast though. A self-test and benchmarking program for the UM was
available from the <a href="http://icfpcontest.org/">ICFP</a> website. Norman's UM ran this benchmark in
minutes but mine, distressingly, took over 10 hours.
</p>

<p>
Last Saturday, after eliminating a few variables and assignments in the
hotpath and using macroes instead, I managed to get the time for the
benchmark program down to just over two hours. A whole lot better, but
still <i>way</i> slower than others' VMs. From basic instrumentation I knew
that the benchmark program does a lot of memory allocation and
deallocation, and I surmised that this the cause of my performance
problems. During the course of the weekend I tried various things to
speed my VM up further by caching previously allocated arrays in various
ways. Whatever I tried, however, simply made it slower. It was a
humbelling experience that reminded me that I should have faith in the
library implementors; they're most likely smarter than me.
</p>

<p>
The performance of my VM continued to bug me and Monday morning. My VM
has an array of pointers to unsigned integer arrays, which the benchmark
program required a whole bunch of. Indexes into the parent array are
used to identify which leaf array it required and therefore I could not
change the index of a leaf array and when a leaf is freed up I end up
with a sparse parent array. My fallacy was to use a sequential scan to
find the first free location in the parent array, when allocating a new
leaf; as it turned out, this was <i>really</i> expensive. When I tried to
just allocate new leaf arrays at the end of the parent array and simply
allowing the parent array to be very sparse at the front, my VM suddenly
ran the benchmark in just over three minutes. A considerable speedup,
but it didn't come for free. As I didn't reuse any of the slots in the
parent array the memory usage grew steeply to about 140 MB, up from
around 3 MB throughout the entire run previously.
</p>

<p>
The morale is clear: <i>Find</i> your bottlenecks, then eliminate them; don't
try to eliminate imagined bottlenecks (I already knew this, but it
doesn't hurt to be reminded once in a while). I originally assumed that
my performance issues was related to memory allocation. I was partly
right, but it was not due to <code>malloc()</code> or <code>free()</code> being slow, as I had
assumed. It was down to my stupid algorithm for finding somewhere to
stash the newly allocated array.
</p>

<p>
<b>Update:</b> By making use of C99's flexible array member and introducing
an extremely simple free list I've now managed to get the memory usage
for my VM down to 2.16 MB (as reported by top on my Powerbook) for the
benchmark run, at a cost of adding about 40&#x2013;50 seconds to the run time.
The flexible array member feature allows me to do only one allocation
instead of two when allocating an array wrapped in a struct; this can
yield large memory savings if you're allocating a lot of structs
containing short arrays. The free list simply holds indices to free
slots in the parent array.
</p>

<p>
<b>Update, 2007/09/03:</b> Here's my <a href="https://github.com/stig/icfp2006/blob/master/um.c">Virtual Machine</a>, should you wish to take
a look.
</p>
</div>
<div id="postamble" class="status">
<p class="author">Author: <a href="/contact.html">Stig Brautaset</a></p>
<p class="licence">Licence: <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
