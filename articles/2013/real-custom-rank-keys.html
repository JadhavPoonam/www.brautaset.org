<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Real custom rank keys</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Stig Brautaset">
<link rel="stylesheet" type="text/css" href="/css/main.css" />
<link rel="icon" type="image/png" href="/images/icon.png" />
<script type="text/javascript">
if(/superloopy.io/.test(window.location.hostname)) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-4113456-6', 'auto');
  ga('send', 'pageview');
}
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>

<div id="org-div-home-and-up">
  <img src="/images/logo.png" alt="Superloopy Logo"/>
  <nav>
    <ul>
      <!-- <li><a accesskey="h" href="/"> Up </a></li>
 -->
      <li><a accesskey="H" href="/"> Home </a></li>
      <li><a accesskey="p" href="/publications.html"> Publications </a></li>
      <li><a accesskey="A" href="/about.html"> About </a></li>
    </ul>
  </nav>
</div>
<div id="content">
<h1 class="title">Real custom rank keys</h1>
<p>
Let me guess: you have, at some point in your career, implemented a
database table with a "rank" field, for user-defined ordering of items
in a collection. In my experience this rank is usually of type INT.
Moving an item to the end is easy: just add (or subtract) 1 from the
rank of the item that was at the end.
</p>

<p>
However, this approach is problematic if you want to allow reordering of
<i>internal</i> items. The two ways I've seen people usually solve this is:
</p>

<ol class="org-ol">
<li>Update all the elements' ranks each time you move an item.</li>
<li>Space out the numbers so there's some room in between.</li>
</ol>

<p>
The first is obviously not ideal if the collections can grow large. If
you're dealing with user defined collections you have to assume they
will. The second, AKA The BASIC approach, will allow you to move any
item to anywhere else by setting its rank to be the average of its new
neighbours&#x2014;assuming there's a gap wide enough.
</p>

<p>
So how big a gap do you chose? 1000? That gives you fewer re-orders than
you first might think, as each re-order halves the gap: /log/(1000)
gives you roughly 6.9 operations. Since it's a logarithmic function it
means that we're seeing diminishing returns as we grow the gap:
/log/(10000) is about 9.2, and even going to /log/(1e6) gives us just
13.8&#x2014;and unless we're dealing with BigInts we might start to get
concerned about the ranks we can deal with at this point.
</p>

<p>
But what if we use floating-point numbers for the rank instead?
Something like this:
</p>

<ol class="org-ol">
<li>First entry gets assigned 0.</li>
<li>Items added at the front gets old max + 1.</li>
<li>Items added at the end gets old min - 1.</li>
<li>Items added elsewhere gets the average of its neighbours.</li>
</ol>

<p>
The positive range of Float is roughly 3e38 and Double is 1e308. These
both far exceed the number of items a (curated) collection is likely to
hold. So if our main concern is adding to either end, either one would
do and using a float takes less space. (This is probably more relevant
for indices than for actual storage.)
</p>

<p>
Where Float vs Double matter is how many re-order (averaging) operations
they can handle before the difference between one number and the next is
less than the smallest representable number. The worst-case, assuming an
initial gap of 1, is:
</p>

<ul class="org-ul">
<li>Float: 150</li>
<li>Double: 1075</li>
</ul>

<p>
There's probably a fancy mathematical way of determining this, but I
brute-forced it using the following Scala program:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00796b;">def</span> <span style="color: #0097A7;">g</span>(n<span style="color: #00796b;">:</span> <span style="color: #0097A7;">Int</span>, r<span style="color: #00796b;">:</span><span style="color: #0097A7;">Double</span>, lim<span style="color: #00796b;">:</span> <span style="color: #0097A7;">Double</span>)<span style="color: #00796b;">:</span> <span style="color: #0097A7;">Int</span>
    <span style="color: #00796b;">=</span> <span style="color: #00796b;">if</span> (r &lt; lim) n <span style="color: #00796b;">else</span> g(n+<span style="color: #558b2f;">1</span>, r / <span style="color: #558b2f;">2</span>, lim)
g(<span style="color: #558b2f;">0</span>, <span style="color: #558b2f;">1</span>, <span style="color: #558b2f;">Float</span>.<span style="color: #558b2f;">MinPositiveValue</span>)
g(<span style="color: #558b2f;">0</span>, <span style="color: #558b2f;">1</span>, <span style="color: #558b2f;">Double</span>.<span style="color: #558b2f;">MinPositiveValue</span>)
</pre>
</div>

<p>
Of course, there's a chance that number of re-orderings will exceed even
this scheme. (Although, if they are user-initiated, it is quite
unlikely.) In that case you may have to enumerate the whole collection
again. Or maybe you can be smart and distribute ranks of neighbours as
you go. This is left as an exercise to the reader.
</p>

<p>
<i>Disclaimer: I have only theorised about this technique; I have not used
it in anger yet.</i>
</p>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2013-02-23</p>
<p class="author">Author: Stig Brautaset</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
