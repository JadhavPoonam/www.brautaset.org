<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2017-06-07 Wed 16:22 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MiniMax and AlphaBeta Search</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Stig Brautaset">
<link rel="stylesheet" type="text/css" href="/css/main.css" />
      <link rel="icon" type="image/png" href="/images/icon.png" />
<script type="text/javascript">
if(/superloopy.io/.test(window.location.hostname)) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-4113456-6', 'auto');
  ga('send', 'pageview');
}
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>

<div id="org-div-home-and-up">
  <img src="/images/logo.png" alt="Superloopy Logo"/>
  <nav>
    <ul>
      <!-- <li><a accesskey="h" href="/"> Up </a></li>
 -->
      <li><a accesskey="H" href="/"> Home </a></li>
      <li><a accesskey="a" href="/articles"> Articles </a></li>
      <li><a accesskey="p" href="/publications.html"> Publications </a></li>
      <li><a accesskey="A" href="/about.html"> About </a></li>
    </ul>
  </nav>
</div>
<div id="content">
<h1 class="title">MiniMax and AlphaBeta Search</h1>
<div class="abstract">
<p>
I try to give an overview of &amp; explain (perhaps mainly to myself) the
MiniMax algorithm and its AlphaBeta pruning optimisation.
</p>

</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#the-minimax-algorithm">The Minimax algorithm</a></li>
<li><a href="#depth-limited-minimax">Depth-limited Minimax</a></li>
<li><a href="#alpha-beta-pruning">Alpha-Beta pruning</a></li>
</ul>
</div>
</div>
<div id="list-of-listings">
<h2>List of Listings</h2>
<div id="text-list-of-listings">
<ul>
<li><a href="#org755e590"><span class="listing-number">Listing 1:</span> Example MiniMax implementation</a></li>
<li><a href="#org7744d0b"><span class="listing-number">Listing 2:</span> Example MiniMax implementation for root</a></li>
<li><a href="#orgae5f85a"><span class="listing-number">Listing 3:</span> Example depth-limited MiniMax implementation</a></li>
<li><a href="#org8355926"><span class="listing-number">Listing 4:</span> Example AlphaBeta pruning</a></li>
</ul>
</div>
</div>

<p>
Though they are quite different from each other Chess, Checkers, Go,
Othello, Connect-4 and Tic-Tac-Toe also have similarities. They are
all two-player <a href="http://en.wikipedia.org/wiki/Zero-sum">zero sum</a> <a href="http://en.wikipedia.org/wiki/Perfect_information">perfect information</a> games. The term <i>two-player</i>
just means that there must be two opposing sides (football is
considered two-player, for example). A <i>zero sum</i> game is one where an
advantage for one player is an equally large disadvantage for the
other. <i>Perfect information</i> basically rules out any game that has an
element of chance. Yatzee? Right out the window. Poker? Forget about
it. Jenga? Not even <i>close</i>.
</p>

<p>
For games that have these properties it is possible to set up a game
tree to aid in the selection of the next move. For simplicity, consider
the starting state of Tic-Tac-Toe to be the root of a tree. The root has
nine branches, each leading to a successor state. Each of these has 8
branches leading to <i>its</i> successor states and so on. Some of the paths
through the tree will end before others (a winning state is reached
before all the slots have been filled) but some paths continue until
depth 9 (or <i>ply</i> 9 in game-tree terminology), when all the slots have
been filled.
</p>

<p>
After having exhausted the search space of the game, it is easy to find
the paths that will lead to victory for either player. Knowing the path
that X can take to the fastest victory is generally of little use,
however, because O can thwart X's plans of a swift victory any time it
is her turn to move. Instead of traversing the path leading to the
fastest possible victory, X's best aim is to pick a path where her
<i>worst</i> outcome will be victory (the <i>best worst-case</i> path). The
Minimax game-tree search algorithm is designed to do just this, and
alpha-beta pruning improves on it. This article tries to explain how
both works.
</p>

<div id="outline-container-orgff5240e" class="outline-2">
<h2 id="the-minimax-algorithm"><a id="orgff5240e"></a>The Minimax algorithm</h2>
<div class="outline-text-2" id="text-the-minimax-algorithm">
<p>
Let us use Tic-Tac-Toe as an example when explaining how the Minimax
algorithm works. The player whose turn it is to move at the root is
called Max, and all even plies in the game-tree (i.e. the states where
it is Max' turn to move) are labelled accordingly. Max' opponent is
called Min. These names are adapted from their actions; Max is always
trying to maximise her score, Min is always trying to minimise Max'
score.
</p>

<p>
To determine who won, a function to evaluate a game state is needed. The
evaluation function takes a game state as its argument and should return
a value indicating whether the state is a win, loss or draw for the
player whose turn it is at that state. The function could for example
return 1 if the state is a win, -1 if the state is a loss and zero if
the state is a draw. The evaluation function is applied to all the leaf
states. Leafs are game states without children, i.e. either a draw, or a
win for one of the players.
</p>

<p>
After exhausting the tree and evaluating all leaf states, Minimax values
are assigned to the internal states (all non-leaf states) of the
game-tree. The Minimax values found in the leaf nodes are inverted and
returned to their parent. Each parent picks the highest value returned
to it, negates it, then returns the result to its parent, et cetera. The
Minimax values returned to the root denote Max' worst outcome for each
corresponding move. All that remains for Max is to pick a move where her
worst outcome is a win (if such a move exists&#x2013;it does not in
Tic-Tac-Toe).
</p>

<p>
The following method shows how the Minimax algorithm can be implemented
in Objective-C. A noticeable difference from the description above is
that the Minimax value is negated on return from the recursive call
instead of before the return; this is how the Minimax algorithm is
normally implemented.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Example MiniMax implementation</label><pre class="src src-objc" id="org755e590">-(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold;">minimaxWithState</span>:(<span style="font-weight: bold; text-decoration: underline;">id</span>)<span style="font-weight: bold; font-style: italic;">state</span> <span style="font-weight: bold;">player</span>:(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold; font-style: italic;">player</span> {
  <span style="font-weight: bold;">if</span> ([state isEndOfGame])
    <span style="font-weight: bold;">return</span> [state evaluateWithPlayer:player];

  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">score</span> = -1; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">value for loss</span>
  <span style="font-weight: bold; text-decoration: underline;">NSArray</span> *<span style="font-weight: bold; font-style: italic;">moves</span> = [state movesAvailable];
  <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">enumerator</span> = [moves objectEnumerator];
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">m</span>; m = [enumerator nextObjnextObject]; ) {
    <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">s2</span> = [state successorStateWithMove:m];
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">sc</span> = -[<span style="font-weight: bold;">self</span> minimaxWithState:s2 player:3 - player];
    <span style="font-weight: bold;">if</span> (sc &gt; score)
      score = sc;
  }
  <span style="font-weight: bold;">return</span> score;
}
</pre>
</div>

<p>
The next listing shows the special Minimax function applied to the
root of the tree (i.e. the position for which a move is sought). In
discussions of the algorithm the notion of any special treatment of
the root is often omitted; it is included here for the sake of
completeness. It retains the best move in addition to its score, so we
can later apply it to advance the game.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Example MiniMax implementation for root</label><pre class="src src-objc" id="org7744d0b">-(<span style="font-weight: bold; text-decoration: underline;">id</span>)<span style="font-weight: bold;">minimaxRootWithState</span>:(<span style="font-weight: bold; text-decoration: underline;">id</span>)<span style="font-weight: bold; font-style: italic;">state</span> <span style="font-weight: bold;">player</span>:(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold; font-style: italic;">player</span> {
  <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">bestmove</span> = <span style="font-weight: bold; text-decoration: underline;">nil</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">score</span> = -1; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">value for</span>
  loss <span style="font-weight: bold; text-decoration: underline;">NSArray</span> *<span style="font-weight: bold; font-style: italic;">moves</span> = [state movesAvailable];
  <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">enumerator</span> = [moves objectEnumerator];
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">m</span>; m = [enumerator nextObject]; ) {
    <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">s2</span> = [state successorStateWithMove:m];
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">sc</span> = -[<span style="font-weight: bold;">self</span> minimaxWithState:s2 player:3 - player];
    <span style="font-weight: bold;">if</span> (sc &gt; score) {
      bestmove = m;
      score = sc;
    }
  }
  <span style="font-weight: bold;">return</span> bestmove;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge34c993" class="outline-2">
<h2 id="depth-limited-minimax"><a id="orge34c993"></a>Depth-limited Minimax</h2>
<div class="outline-text-2" id="text-depth-limited-minimax">
<p>
Only when the search space is sufficiently small, like in our
Tic-Tac-Toe example, is it possible to exhaust it fully using the
Minimax algorithm. For practical applications this is almost never the
case. Computers are not powerful enough to exhaust game-trees for
practical applications where game-tree search would be desired. For
example, it has been claimed that the game of Chess has more states than
there are atoms in the known universe. Suffice to say that waiting for a
search of that magnitude to finish becomes impractical.
</p>

<p>
A simple way of ensuring that the search will terminate in a practical
timespan is to set a maximum limit on the depth of the search. The
following method shows how the Minimax algorithm presented earlier can
be amended to unconditionally stop after reaching a certain depth.
Notice that the initial value for score has changed.
</p>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Example depth-limited MiniMax implementation</label><pre class="src src-objc" id="orgae5f85a">-(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold;">minimaxWithState</span>:(<span style="font-weight: bold; text-decoration: underline;">id</span>)<span style="font-weight: bold; font-style: italic;">state</span> <span style="font-weight: bold;">player</span>:(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold; font-style: italic;">player</span> <span style="font-weight: bold;">ply</span>:(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold; font-style: italic;">ply</span> {
  <span style="font-weight: bold;">if</span> (!ply || [state isEndOfGame])
    <span style="font-weight: bold;">return</span> [state evaluateWithPlayer:player];
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">score</span> = -1000; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">value for loss</span>
  <span style="font-weight: bold; text-decoration: underline;">NSArray</span> *<span style="font-weight: bold; font-style: italic;">moves</span> = [state movesAvailable];
  <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">enumerator</span> = [moves objectEnumerator];
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">m</span>; m = [enumerator nextObject]; ) {
    <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">s2</span> = [state successorStateWithMove:m];
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">sc</span> = -[<span style="font-weight: bold;">self</span> minimaxWithState:s2 player:3 - player];
    <span style="font-weight: bold;">if</span> (sc &gt; score)
      score = sc;
  }
  <span style="font-weight: bold;">return</span> score;
}
</pre>
</div>

<p>
Since the search may be terminated before it has reached the leaf nodes,
the end states of many paths are lost. Thus the evaluation function will
have to be enhanced: it must now be able to indicate how good
non-terminal states in the game-tree are, in contrast to simply
determining a win, loss or draw for an end state. Instead of returning
-1, 0 or 1 the evaluation function must now return a value in a certain
range (say, -1000 to 1000) indicating how good the state is. Performance
of depth-limited Minimax algorithms greatly depends on how well the
evaluation function identifies strong states.
</p>
</div>
</div>

<div id="outline-container-org4caa5fa" class="outline-2">
<h2 id="alpha-beta-pruning"><a id="org4caa5fa"></a>Alpha-Beta pruning</h2>
<div class="outline-text-2" id="text-alpha-beta-pruning">
<p>
In the late 50s it was realised that it was not necessary to visit all
the nodes in a game-tree to correctly deduce its Minimax value.
Uninteresting branches of the tree can be pruned away. Remember that the
Minimax algorithm produces the value of the best worst-case. Alpha-Beta
pruning terminates the search of a subtree as soon as it knows that the
worst-case for the subtree is worse than previously searched paths. The
idea is that if a path is worse than the current best path, time is not
wasted trying to find out <i>how</i> bad it is.
</p>

<p>
To accomplish the pruning mentioned above two bounds are passed to a
modified Minimax algorithm. The bounds are the highest (beta) and lowest
(alpha) value that can affect the Minimax value at that point, and are
continually updated as the search progresses. Since the Minimax value is
negated at each step, the states of the bounds must also be negated and
their states switched as they are passed on to the next level. If the
Minimax value returned from a path is greater than or equal to the high
bound, the path is pruned. Here's an example:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Example AlphaBeta pruning</label><pre class="src src-objc" id="org8355926">-(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold;">alphaBetaWithState</span>:(<span style="font-weight: bold; text-decoration: underline;">id</span>)<span style="font-weight: bold; font-style: italic;">state</span> <span style="font-weight: bold;">player</span>:(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold; font-style: italic;">player</span> <span style="font-weight: bold;">ply</span>:(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold; font-style: italic;">ply</span> <span style="font-weight: bold;">alpha</span>:(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold; font-style: italic;">alpha</span> <span style="font-weight: bold;">beta</span>:(<span style="font-weight: bold; text-decoration: underline;">int</span>)<span style="font-weight: bold; font-style: italic;">beta</span> {
  <span style="font-weight: bold;">if</span> (!ply || [state isEndOfGame])
    <span style="font-weight: bold;">return</span> [state evaluateWithPlayer:player];
  <span style="font-weight: bold; text-decoration: underline;">NSArray</span> *<span style="font-weight: bold; font-style: italic;">moves</span> = [state movesAvailable];
  <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">enumerator</span> = [moves objectEnumerator];
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">m</span>; m = [enumerator nextObject]; ) {
    <span style="font-weight: bold; text-decoration: underline;">id</span> <span style="font-weight: bold; font-style: italic;">s2</span> = [state successorStateWithMove:m];
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">sc</span> = -[<span style="font-weight: bold;">self</span> alphaBetaWithState:s2
                                player:3 - player
                                   ply:ply-1
                                 alpha:-beta
                                  beta:-alpha];
    <span style="font-weight: bold;">if</span> (sc &gt; alpha)
      alpha = sc;
    <span style="font-weight: bold;">if</span> (alpha &gt;= beta)
      <span style="font-weight: bold;">break</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">prune branch.</span>
  }
  <span style="font-weight: bold;">return</span> alpha;
}
</pre>
</div>

<p>
In a worst-ordered tree (where the paths are ordered so that no pruning
occurs) the Alpha-Beta algorithm visits the same number of leaf nodes as
Minimax. On average it performs a lot better. Given a perfectly ordered
tree, where the branches are pruned as early as possible, the Alpha-Beta
algorithm can search twice as deep as the Minimax algorithm in the same
timespan.
</p>

<p>
<i>This post has been adapted from a section of my 2003 BSc Artificial Intelligence report on Generalised Game-Tree Search at the University of Westminster.</i>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2007-08-17</p>
<p class="author">Author: Stig Brautaset</p>
<p class="date">Created: 2017-06-07 Wed 16:22</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
